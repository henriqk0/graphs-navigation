
# üßæ Relat√≥rio de Desenvolvimento - Biblioteca de Grafos & Aplicativo de Navega√ß√£o

> **Integrantes (Grupo 4 )**: Gabriel, Guilherme, Henrique, Miguel  
> **Tecnologia Principal**: Java  
> **Objetivo**: Desenvolver uma biblioteca de grafos reutiliz√°vel e uma aplica√ß√£o pr√°tica que a utilize.

---

## üìå 1. Introdu√ß√£o

Este relat√≥rio descreve o processo de desenvolvimento de uma biblioteca de grafos em **Java**, juntamente com uma aplica√ß√£o que a utiliza. Ser√£o abordadas as **estrat√©gias de representa√ß√£o dos grafos**, os **algoritmos cl√°ssicos implementados**, o **uso pr√°tico desses algoritmos**, al√©m do apoio de ferramentas de **Intelig√™ncia Artificial (IA/LLM)** no desenvolvimento.

---

## üß© 2. Representa√ß√£o de Grafos

A implementa√ß√£o da biblioteca de grafos possui duas representa√ß√µes na forma de classes:
- V√©rtices (Vertex<T>);
- Grafos (Graph<T>)

Uma inst√¢ncia de Vertex<T> √© um objeto simples que cont√©m um tipo T gen√©rico que representa seu valor, como representado no c√≥digo abaixo:
````java
public class Vertex<T>{
    private T value;
    
    public T getValue(){return this.value;}
    public void setValue(T v){this.value = v;}
    
    
}
````

Uma inst√¢ncia de Graph<T> cont√©m dois atributos:
- Uma lista dos v√©rtices existentes para o tipo gen√©rico T (do tipo ArrayList<Vertex<T>>);
- Uma matriz de adjac√™ncia (do tipo ArrayList<ArrayList<Float>>);
- Uma flag para dizer se o grafo √© ou n√£o direcionado (do tipo boolean)

O c√≥digo abaixo mostra a implementa√ß√£o geral da classe Graph<T>: 
````java
public class Graph<T>{
    private final ArrayList<Vertex<T>> vertices; // List of vertices
    private ArrayList<ArrayList<Float>> edges; // Adjacency matrix to represent edges
    private boolean directed; // Default is false

    public Graph() {
        this.vertices = new ArrayList<>();
        this.edges = new ArrayList<>();
        this.directed = false;
    }
    
    //M√©todos
}
````

---

## üß† 3. Algoritmos Cl√°ssicos de Grafos

### **Dijkstra**

O m√©todo dijkstra(T origin, T destination) implementa o algoritmo de Dijkstra com o objetivo de encontrar o menor custo de caminho entre dois v√©rtices de um grafo ponderado. A premissa do algoritmo √© que todas as arestas possuem pesos n√£o negativos. Na implementa√ß√£o abaixo, o m√©todo retorna apenas o valor total do caminho mais curto entre os v√©rtices origin e destination, assumindo que o destino √© alcan√ß√°vel a partir da origem:


````java
public float dijkstra(T origin, T destination) { // assuming that the destination is reachable from the origin vertex
    try {
      int originIndex = getVertexIndex(origin);
      int destinationIndex = getVertexIndex(destination);

      if (originIndex == -1 || destinationIndex == -1) { 
        throw new Exception();
      }

      float[] distances = toFullFloatArray(this.edges.size(), 99999);
      int[] predecessors = toFullIntArray(this.edges.size(), 0);
      boolean[] visited = new boolean[this.edges.size()];

      distances[originIndex] = 0;
      predecessors[originIndex] = -1;
     
      int i = originIndex;
      float minDistance;

      visited[originIndex] = true;
      for (int n = 0; n < this.edges.size() && visited[destinationIndex] == false; n++) { // worst case -> n - 1 times
        minDistance = 99999;

        for (int j = 0; j < this.edges.size(); j++) { // to pick all weight values from `i` vertex
          float pathWeight = this.edges.get(i).get(j); 

          if (pathWeight != 0) { // existence of an edge to `j`
            if (visited[j] == false && pathWeight + distances[i] < distances[j] ) { // new distance < previous stored distance
              distances[j] = pathWeight + distances[i];  // then, update the minimal distance to vertex `j`
              predecessors[j] = i;  // update the last predecessor from `j`
            }
          }
        }

````

O algoritmo inicia obtendo os √≠ndices dos v√©rtices de origem e destino:

```java
int originIndex = getVertexIndex(origin);
int destinationIndex = getVertexIndex(destination);
```

Caso qualquer um dos v√©rtices n√£o seja encontrado no grafo (√≠ndice igual a -1), uma exce√ß√£o √© lan√ßada:

```java
if (originIndex == -1 || destinationIndex == -1) {
    throw new Exception();
}
```

Em seguida, s√£o inicializados tr√™s vetores auxiliares:

- `distances`: guarda a menor dist√¢ncia conhecida at√© cada v√©rtice (inicializado com `99999`).
- `predecessors`: armazena o √∫ltimo v√©rtice anterior no caminho m√≠nimo.
- `visited`: indica se um v√©rtice j√° foi processado.

```java
float[] distances = toFullFloatArray(this.edges.size(), 99999);
int[] predecessors = toFullIntArray(this.edges.size(), 0);
boolean[] visited = new boolean[this.edges.size()];

distances[originIndex] = 0;
predecessors[originIndex] = -1;
```

O la√ßo principal se repete no m√°ximo `n` vezes (onde `n` √© o n√∫mero de v√©rtices), ou at√© que o destino seja alcan√ßado. Ele percorre os vizinhos do v√©rtice atual (`i`) buscando caminhos mais curtos:

```java
for (int n = 0; n < this.edges.size() && visited[destinationIndex] == false; n++) {
    ...
}
```

Em cada itera√ß√£o, o algoritmo percorre todos os v√©rtices `j` verificando a exist√™ncia de uma aresta `i ‚Üí j`:

```java
float pathWeight = this.edges.get(i).get(j);
if (pathWeight != 0) {
    ...
}
```

Se `j` ainda n√£o foi visitado e o novo caminho atrav√©s de `i` √© mais curto, os valores s√£o atualizados:

```java
if (!visited[j] && pathWeight + distances[i] < distances[j]) {
    distances[j] = pathWeight + distances[i];
    predecessors[j] = i;
}
```

Percorrido todas as arestas que partem de `i`, marcamos o v√©rtice `i` como visitado, obtendo, em seguida o caminho de menor peso dentre os v√©rtices n√£o marcados, para a pr√≥xima atualizar o valor de `i` na pr√≥xima itera√ß√£o, para que se fa√ßa as verifica√ß√µes restantes: 

```java
visited[j] 
for (int j = 0; j < this.edges.size(); j++) { // pick next vertex with minimal distance before destination
  if (visited[j] == false && distances[j] < minDistance) {
    minDistance = distances[j];
    i = j;
  }
}
```

Esta implementa√ß√£o utiliza uma **matriz de adjac√™ncia** e uma abordagem de **for√ßa bruta** para sele√ß√£o do pr√≥ximo v√©rtice. Isso resulta em uma complexidade de tempo:

```
O(n¬≤)
```

Essa abordagem √© aceit√°vel para grafos **pequenos ou densos**, mas se torna ineficiente em grafos **grandes ou esparsos**.

Para melhorar a efici√™ncia, seria bom:

- Utilizar uma **lista de adjac√™ncia** no lugar da matriz;
- Adotar uma **fila de prioridade** (min-heap) para selecionar o pr√≥ximo v√©rtice com menor dist√¢ncia;

Com essas mudan√ßas, √© poss√≠vel atingir complexidade:

```
O((V + E) log V)
```
 
Essa vers√£o do algoritmo de Dijkstra √© simples e funcional, ideal para fins educacionais e grafos de pequena escala. Contudo, para aplica√ß√µes reais com grande volume de dados, adapta√ß√µes estruturais s√£o fortemente recomendadas.

### **√Årvore Geradora M√≠nima**


O m√©todo `minnimalSpanningTree()` implementa o algoritmo de Prim para encontrar o custo total da **√Årvore Geradora M√≠nima** (MST - Minimum Spanning Tree) de um grafo n√£o direcionado e ponderado. A fun√ß√£o retorna esse custo como um valor `float`, assumindo que o grafo √© conexo e que os pesos das arestas s√£o todos positivos.
Segue abaixo o trecho de c√≥digo que implementa o algoritmo:



````java
public int minIndxPrim(int[] predecessors, float[] weights, boolean[] inTree, int row) {
  float minWeight = 99999;

  int j = 0;
  for (int indx = 0; indx < inTree.length; indx++) {
    if (inTree[indx] == false && this.edges.get(row).get(indx) < minWeight) {
      minWeight = weights[indx];
      j = indx;
    }
  }
  return j;
}

public float minnimalSpanningTree(){
  if (this.edges.isEmpty()) return 0;

  else {
    float[] weights = toFullFloatArray(this.edges.size(), 99999);
    int[] predecessors = toFullIntArray(this.edges.size(), 0);
    boolean[] itsInTree = new boolean[this.edges.size()];

    weights[0] = 0;
    predecessors[0] = -1;

    for (int aux = 0; aux < itsInTree.length - 1; aux++) {
      int j = minIndxPrim(predecessors, weights, itsInTree, aux);

      itsInTree[j] = true;

      for (int w = 0; w < itsInTree.length; w++) {
        if (this.edges.get(j).get(w) > 0 && itsInTree[w] == false &&
          this.edges.get(j).get(w) < weights[w] ) {
          predecessors[w] = j;
          weights[w] = this.edges.get(j).get(w);
        }
      }
      itsInTree[j] = true;
    }

    float total = 0;
    for (float wgt : weights) {
      total += wgt;
    }
    System.out.println("Rotas:");
    for (int i = 0; i < weights.length; i++) {
      if (weights[i] != 0) {
        System.out.println(this.vertices.get(predecessors[i]).getValue() + " -(Risco: "
        + weights[i] +")-> " 
        + this.vertices.get(i).getValue());
      }
    }
    return total;
  }
}
````

A fun√ß√£o verifica inicialmente se o grafo est√° vazio:

```java
if (this.edges.isEmpty()) return 0;
```

Se houver v√©rtices e arestas, o algoritmo inicializa tr√™s vetores auxiliares:

- `weights`: guarda os menores pesos conhecidos de arestas conectando v√©rtices fora da √°rvore.
- `predecessors`: mant√©m o √≠ndice do v√©rtice anterior na √°rvore (n√£o usado diretamente no retorno).
- `itsInTree`: indica se o v√©rtice j√° foi inclu√≠do na √°rvore geradora.

```java
float[] weights = toFullFloatArray(this.edges.size(), 99999);
int[] predecessors = toFullIntArray(this.edges.size(), 0);
boolean[] itsInTree = new boolean[this.edges.size()];

itsInTree[0] = true;
predecessors[0] = -1;
```

O v√©rtice de √≠ndice `0` √© escolhido como ponto de partida, sendo o primeiro inclu√≠do na √°rvore.


O la√ßo externo executa `n - 1` vezes, onde `n` √© o n√∫mero de v√©rtices. A cada itera√ß√£o, o algoritmo escolhe a pr√≥xima aresta de menor peso que conecta um v√©rtice fora da √°rvore:

```java
for (int aux = 0; aux < itsInTree.length - 1; aux++) {
    ...
}
```

Dentro do la√ßo, o trecho abaixo busca o v√©rtice `j` que tem o menor peso de conex√£o com a √°rvore atual:

```java
for (indx = 0; indx < itsInTree.length; indx++) {
    if (!itsInTree[indx] && this.edges.get(aux).get(indx) < minWeight) {
        minWeight = weights[indx];
        j = indx;
    }
}
```

Depois, o v√©rtice `j` √© inclu√≠do na √°rvore:

```java
itsInTree[j] = true;
```

Em seguida, o algoritmo atualiza os pesos e predecessores para os v√©rtices vizinhos de `j`, caso encontre conex√µes mais baratas:

```java
for (int w = 0; w < itsInTree.length; w++) {
    if (this.edges.get(j).get(w) > 0 && !itsInTree[w] &&
        this.edges.get(j).get(w) < weights[w]) {
        predecessors[w] = j;
        weights[w] = this.edges.get(j).get(w);
    }
}
```


Esta implementa√ß√£o de Prim utiliza uma **matriz de adjac√™ncia** e busca o pr√≥ximo v√©rtice de forma **linear**, o que resulta em uma complexidade de tempo:

```
O(n¬≤)
```

onde `n` √© o n√∫mero de v√©rtices. Isso se deve ao fato de que, em cada uma das `n` itera√ß√µes, percorremos novamente todos os v√©rtices (`n` buscas internas).


O m√©todo `minnimalSpanningTree()` apresenta uma implementa√ß√£o funcional e direta do algoritmo de Prim, retornando o custo total da √°rvore geradora m√≠nima. Embora simples e did√°tico, seu desempenho pode ser melhorado significativamente em casos com muitos v√©rtices e poucas arestas atrav√©s de otimiza√ß√µes estruturais.

---

## üöÄ 4. Aplica√ß√£o Pr√°tica & Manual de Uso

### üì± Descri√ß√£o da Aplica√ß√£o
A aplica√ß√£o de navega√ß√£o veio com a proposta de facilitar a gest√£o de tr√°fego mar√≠timo. Ele visa resolver problemas de efici√™ncia com o planejamento de rotas, oferencendo um conjunto de funcionalidades que o usu√°rio navegador pode utilizar em suas viagens.
### üõ†Ô∏è Funcionalidades
A aplica√ß√£o se utiliza do conceito de grafos e algoritmos para trazer dados informativos de maneira que o usu√°rio possa:
- Acessar os pontos de embarque e desembarque disponiveis;
- Adicionar portos personalizados;
- Visualizar um mapa com todos os portos definidos;
- Informar a rota mais curta entre um ponto de embarca√ß√£o e outro;
- Informar a rota global mais "segura".

### üìò Manual de Uso
Para executar a aplica√ß√£o, faz-se necess√°ria um IDE como, por exemplo, o JEtBrains IntelliJ.
Ao extrair o projeto do reposit√≥rio (link do github no final da documenta√ß√£o), haver√° duas pastas separadas no caminho *src/main/java/com:* **app** e **lib**

Ao acessar a pasta **app**, a classe inicial para a execu√ß√£o do programa estar√° logo na sua raiz; √© uma classe chamada **Application**. 

Na execu√ß√£o da classe **Application**, a seguinte interface aparecer√° no terminal:

```bash
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó                                        
‚ïë           BEM VINDO!          ‚ïë          ¬´‚ñë‚ñë‚ñí‚ñí‚ïó                       
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£               ‚ñê                        
‚ïë      Selecione uma op√ß√£o:     ‚ïë             ‚ñë‚ñì‚ñê‚ñì‚ñí‚ñë                      
‚ïë ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚ïë            ‚ñë‚ñí‚ñì‚ñê‚ñì‚ñì‚ñì‚ñí‚ñí‚ñë                   
‚ïë   1) Criar um mapa            ‚ïë           ‚ñë‚ñí‚ñì‚ñì‚ñê‚ñì‚ñì‚ñì‚ñì‚ñì‚ñí‚ñí‚ñí‚ñë                
‚ïë   2) Adicionar um porto       ‚ïë          ‚ñë‚ñí‚ñí‚ñì‚ñì‚ñê‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñí‚ñí‚ñí‚ñë‚ñë             
‚ïë   3) Adicionar uma rota       ‚ïë    ‚ñÄ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ    ‚ñê       ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ         
‚ïë   4) Visualizar mapa          ‚ïë     ‚ñÄ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà         
‚ïë   5) Rota global mais segura  ‚ïë       ‚ñÄ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ‚ñÄ           
‚ïë   6) Melhor caminho A->B      ‚ïë      ¬´‚ñì‚ñì‚ñì‚ñÄ‚ñÄ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ‚ñÄ‚ñÄ               
‚ïë   0) Sair                     ‚ïë      ¬´‚ïú      ‚ñÄ‚ñÄ‚ñÄ‚ñÄ                      
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   
```
Ela cont√©m 6 op√ß√µes (excluindo a op√ß√£o de sair), assim como representada acima; cada uma respons√°vel por uma funcionalidade espec√≠fica

1.  Criar um novo mapa (instancia um novo grafo);
2. Adicionar um porto (instancia um novo v√©rtice ao grafo criado);
3. Adicionar uma nova rota (define uma aresta entre dois v√©rtices do grafo instanciado);
4. Visualizar o mapa (Printa uma estrutura do grafo instanciado); 
5. Informa a rota global mais segura (Define, por meio da √Årvore Geradora M√≠nima, a rota global mais segura de navega√ß√£o)
6. Informa o melhor caminho entre dois portos (Define, por meio de Djikstra, o caminho m√≠nimo entre dois v√©rtices do grafo instanciado)

---

## ü§ñ 5. Uso de Ferramentas de IA/LLM no Desenvolvimento

Foi utilizado o **Manus** para a cria√ß√£o do template desta documenta√ß√£o e o **ChatGPT** para refino visual e de estrutura. Isto gerou economia de tempo na elabora√ß√£o e montagem da documenta√ß√£o. 

Embora n√£o se trate de LLM, as explica√ß√µes e c√≥digos fornecidos pelo site geekforgeeks e pelos slides/videoaulas foram amplamente utilizados na corre√ß√£o e desenvolvimento dos c√≥digos utilizados. Por vezes, d√∫vidas de sintaxe da linguagem Java foram rapidamente solucionadas pela ferramenta de pesquisa Gemini, agora integrada nas pesquisas comuns do Google.

---

## üë• 6. Contribui√ß√µes Individuais

| Integrante      | Responsabilidades principais                        |
|------------------|------------------------------------------------------|
| Gabriel        | Documenta√ß√£o do projeto;Montagem de arquitetura MVC da aplica√ß√£o        |
| Guilherme        | Lib da Matriz de Adjac√™ncia e APP                   |
| Henrique         | Algoritmos Dijaskra, Prim e APP               |
| Miguel           | APP                   |

---

## üìÇ 7. Reposit√≥rio do Projeto

üîó [Graphs Navigation](https://github.com/henriqk0/graphs-navigation)

---
